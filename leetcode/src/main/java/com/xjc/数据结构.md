# 线性表

> 按线性表的存储结构划分出了不同的数据结构：顺序表，链表，map
> 1. 线性表的随机存储 --》链表 --》顺序存取
> 2. 线性表的顺序存储 --》顺序表 --》 随机存取
     一维数组可以看成是一个线性表，在计算机中顺序存储，随机存取，可以通过下标直接访问
     多维数组是元素位线性表的线性表，这里涉及到行列存储和读取，计算机时按行读取的，所以按行存储效率更高一下，如果为了压缩空间，则涉及到矩阵的存储方法。
> 3. map可以理解为特殊的线性表存储结构：
     简单的map利用数组就可以实现 ，但当元素变多是，要确定有没有重复元素就会变得费时，所有有了hashmap，根据key的hash值来快速确定map中是否已经有该键（类似于内存地址的哈希值，用于快速查找）
     散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组烟花而来。可以说，如果没有数组，就没有散列表。
     来自 <https://www.jianshu.com/p/8da83894e38d>
     散列表只是其中一种实现，java常见的还有
     四个实现类,分别是HashMap
     Hashtable
     LinkedHashMap
     TreeMap.
     ConcurrentHashMap
     其中hashmap是通过数组加链表实现的。
     来自 <https://blog.csdn.net/lcr_happy/article/details/95238710>
> 4. 还有一个set类
     set下有hashset 和treeset

## 链表

### 单链表:

插入操作：
指定节点后插入元素时间复杂度O(1)，
指定节点前插入元素时间复杂度通常为O(n),可以后插然后交换data，时间复杂度为O（1）；
删除操作：
删除指定节点时间复杂度通常为O（n），可以先与后一个节点交换data然后删除后一节点
但是如果该节点是尾节点则依然需要遍历链表找到其前一节点，置指针为空。

### 双链表：

指定节点的插入与删除时间复杂度都为O（1）；

单链表与双链表删除第i个元素时间复杂度都是o（n），都需要从头遍历，找到第i个元素。

单链表和顺序表查找操作，单链表能用折半查找吗？
折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。

链表的定义
Lnode *p=L->next是定义了Lnode类型的指针，
那么Lnode a1=*L->next可以定义是头结点吗。*p代表取出指针指向地址的值
那么a1->next和p->next有什么区别？
可以这样定义，只不过访问方式不一样，用“.”取出成员变量，如下

``` C++
int num=3;
s->next = NULL;
s->data = num;
p->data = num;
s->next = p->next;
p->next = s;

printf("%d\n",s->data);
printf("Hello world!\n") 
// 验证 *是取出指针指向地址的数据，即*p可以当作Lnode型变量使用，用“.”访问结构内变量
printf("%d\n",(*((*p).next)).data);
printf("Hello world!\n");

LNode nodel = *(p->next);
printf("%d\n",nodel.data);
```

输出结果：

```
3
Helloworld! 
3
Helloworld! 
3
```

## 集合（set）

set下面有Hashset和TreeSet
Hashset顾名思义里面是哈希表结构
TreeSet就是树结构
1、TreeSet 是二差树实现的,Treeset中的数据度是自动排好序的，不允许放入null值。
2、HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不回能重复，就如数据库中唯一约束。
3、HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相答同内容的
String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例 。

来自 <https://zhidao.baidu.com/question/2078785108855042348.html>

## 红黑树与二叉平衡树

红黑树的性质：

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质:
从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

平衡二叉树的性质：

它是一
棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(
logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

区别：

1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。
————————————————
版权声明：本文为CSDN博主「qfc8930858」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接： https://blog.csdn.net/qfc8930858/article/details/89856274






